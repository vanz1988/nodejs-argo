<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Canvas and MD5 Hash Example</title>
        <style>
            .hash-container {
                margin: 20px 0;
                padding: 15px;
                border: 1px solid #ddd;
                border-radius: 5px;
                background-color: #f8f9fa;
                max-width: 800px;
            }

            .hash-value {
                font-family: monospace;
                word-break: break-all;
                margin: 10px 0;
                padding: 10px;
                background-color: #f1f1f1;
                border-radius: 4px;
            }

            .copy-btn {
                padding: 8px 15px;
                background-color: #4CAF50;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                transition: background-color 0.3s;
            }

            .copy-btn:hover {
                background-color: #45a049;
            }

            .copy-btn:active {
                background-color: #3e8e41;
            }

            h1 {
                color: #333;
            }
        </style>
        <script>
            function md5(string) {
                function rotateLeft(lValue, iShiftBits) {
                    return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
                }

                function addUnsigned(lX, lY) {
                    const lX8 = (lX & 0x80000000);
                    const lY8 = (lY & 0x80000000);
                    const lX4 = (lX & 0x40000000);
                    const lY4 = (lY & 0x40000000);
                    const lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);
                    if (lX4 & lY4)
                        return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
                    if (lX4 | lY4) {
                        if (lResult & 0x40000000)
                            return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
                        else
                            return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
                    } else
                        return (lResult ^ lX8 ^ lY8);
                }

                function F(x, y, z) {
                    return (x & y) | (~x & z);
                }
                function G(x, y, z) {
                    return (x & z) | (y & ~z);
                }
                function H(x, y, z) {
                    return x ^ y ^ z;
                }
                function I(x, y, z) {
                    return y ^ (x | ~z);
                }

                function FF(a, b, c, d, x, s, ac) {
                    a = addUnsigned(a, addUnsigned(addUnsigned(F(b, c, d), x), ac));
                    return addUnsigned(rotateLeft(a, s), b);
                }

                function GG(a, b, c, d, x, s, ac) {
                    a = addUnsigned(a, addUnsigned(addUnsigned(G(b, c, d), x), ac));
                    return addUnsigned(rotateLeft(a, s), b);
                }

                function HH(a, b, c, d, x, s, ac) {
                    a = addUnsigned(a, addUnsigned(addUnsigned(H(b, c, d), x), ac));
                    return addUnsigned(rotateLeft(a, s), b);
                }

                function II(a, b, c, d, x, s, ac) {
                    a = addUnsigned(a, addUnsigned(addUnsigned(I(b, c, d), x), ac));
                    return addUnsigned(rotateLeft(a, s), b);
                }

                function convertToWordArray(string) {
                    let lWordCount;
                    const lMessageLength = string.length;
                    const lNumberOfWordsTemp1 = lMessageLength + 8;
                    const lNumberOfWordsTemp2 = (lNumberOfWordsTemp1 - (lNumberOfWordsTemp1 % 64)) / 64;
                    const lNumberOfWords = (lNumberOfWordsTemp2 + 1) * 16;
                    const lWordArray = Array(lNumberOfWords - 1);
                    let lBytePosition = 0;
                    let lByteCount = 0;
                    while (lByteCount < lMessageLength) {
                        lWordCount = (lByteCount - (lByteCount % 4)) / 4;
                        lBytePosition = (lByteCount % 4) * 8;
                        lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount) << lBytePosition));
                        lByteCount++;
                    }
                    lWordCount = (lByteCount - (lByteCount % 4)) / 4;
                    lBytePosition = (lByteCount % 4) * 8;
                    lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);
                    lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
                    lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
                    return lWordArray;
                }

                function wordToHex(lValue) {
                    let wordToHexValue = '';
                    let wordToHexValueTemp = '';
                    let lByte;
                    let lCount;
                    for (lCount = 0; lCount <= 3; lCount++) {
                        lByte = (lValue >>> (lCount * 8)) & 255;
                        wordToHexValueTemp = '0' + lByte.toString(16);
                        wordToHexValue = wordToHexValue + wordToHexValueTemp.substr(wordToHexValueTemp.length - 2, 2);
                    }
                    return wordToHexValue;
                }

                let x = [];
                let k, AA, BB, CC, DD, a, b, c, d;
                const S11 = 7
                  , S12 = 12
                  , S13 = 17
                  , S14 = 22;
                const S21 = 5
                  , S22 = 9
                  , S23 = 14
                  , S24 = 20;
                const S31 = 4
                  , S32 = 11
                  , S33 = 16
                  , S34 = 23;
                const S41 = 6
                  , S42 = 10
                  , S43 = 15
                  , S44 = 21;

                string = unescape(encodeURIComponent(string));
                x = convertToWordArray(string);

                a = 0x67452301;
                b = 0xEFCDAB89;
                c = 0x98BADCFE;
                d = 0x10325476;

                for (k = 0; k < x.length; k += 16) {
                    AA = a;
                    BB = b;
                    CC = c;
                    DD = d;
                    a = FF(a, b, c, d, x[k + 0], S11, 0xD76AA478);
                    d = FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
                    c = FF(c, d, a, b, x[k + 2], S13, 0x242070DB);
                    b = FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
                    a = FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
                    d = FF(d, a, b, c, x[k + 5], S12, 0x4787C62A);
                    c = FF(c, d, a, b, x[k + 6], S13, 0xA8304613);
                    b = FF(b, c, d, a, x[k + 7], S14, 0xFD469501);
                    a = FF(a, b, c, d, x[k + 8], S11, 0x698098D8);
                    d = FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
                    c = FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
                    b = FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
                    a = FF(a, b, c, d, x[k + 12], S11, 0x6B901122);
                    d = FF(d, a, b, c, x[k + 13], S12, 0xFD987193);
                    c = FF(c, d, a, b, x[k + 14], S13, 0xA679438E);
                    b = FF(b, c, d, a, x[k + 15], S14, 0x49B40821);
                    a = GG(a, b, c, d, x[k + 1], S21, 0xF61E2562);
                    d = GG(d, a, b, c, x[k + 6], S22, 0xC040B340);
                    c = GG(c, d, a, b, x[k + 11], S23, 0x265E5A51);
                    b = GG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);
                    a = GG(a, b, c, d, x[k + 5], S21, 0xD62F105D);
                    d = GG(d, a, b, c, x[k + 10], S22, 0x2441453);
                    c = GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
                    b = GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
                    a = GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
                    d = GG(d, a, b, c, x[k + 14], S22, 0xC33707D6);
                    c = GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
                    b = GG(b, c, d, a, x[k + 8], S24, 0x455A14ED);
                    a = GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
                    d = GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
                    c = GG(c, d, a, b, x[k + 7], S23, 0x676F02D9);
                    b = GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
                    a = HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
                    d = HH(d, a, b, c, x[k + 8], S32, 0x8771F681);
                    c = HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
                    b = HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
                    a = HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
                    d = HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
                    c = HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
                    b = HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
                    a = HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
                    d = HH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);
                    c = HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
                    b = HH(b, c, d, a, x[k + 6], S34, 0x4881D05);
                    a = HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
                    d = HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
                    c = HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
                    b = HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
                    a = II(a, b, c, d, x[k + 0], S41, 0xF4292244);
                    d = II(d, a, b, c, x[k + 7], S42, 0x432AFF97);
                    c = II(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
                    b = II(b, c, d, a, x[k + 5], S44, 0xFC93A039);
                    a = II(a, b, c, d, x[k + 12], S41, 0x655B59C3);
                    d = II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
                    c = II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
                    b = II(b, c, d, a, x[k + 1], S44, 0x85845DD1);
                    a = II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
                    d = II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
                    c = II(c, d, a, b, x[k + 6], S43, 0xA3014314);
                    b = II(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
                    a = II(a, b, c, d, x[k + 4], S41, 0xF7537E82);
                    d = II(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
                    c = II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
                    b = II(b, c, d, a, x[k + 9], S44, 0xEB86D391);
                    a = addUnsigned(a, AA);
                    b = addUnsigned(b, BB);
                    c = addUnsigned(c, CC);
                    d = addUnsigned(d, DD);
                }

                return wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);
            }

            function Z() {
                try {
                    var e = document.createElement("canvas");
                    e.width = 1500;
                    e.height = 300;
                    e.style.display = "block";
                    var t = e.getContext("2d");

                    if (t) {
                        t.textBaseline = "middle";
                        t.fillStyle = "#4b8e8d";
                        t.fillRect(200, 50, 100, 30);
                        t.fillStyle = "#ff6347";
                        t.font = "14pt Courier New";
                        t.globalCompositeOperation = "screen";
                        t.fillStyle = "rgb(0,255,255)";
                        t.beginPath();
                        t.arc(250, 150, 75, 0, 2 * Math.PI, true);
                        t.closePath();
                        t.fill();
                        t.fillStyle = "rgb(255,165,0)";
                        t.arc(250, 150, 50, 0, 2 * Math.PI, true);
                        t.arc(250, 150, 30, 0, 2 * Math.PI, true);
                        t.fill("evenodd");

                        var r = e.toDataURL();
                        return md5(r);
                    }
                } catch (e) {
                    console.error("Error generating canvas or hash:", e);
                }
                return null;
            }

            // 复制哈希值到剪贴板
            function copyHash() {
                const hashElement = document.getElementById("canvashash");
                const hashText = hashElement.textContent.replace("Hash: ", "");

                navigator.clipboard.writeText(hashText).then( () => {
                    // 显示复制成功提示
                    const copyBtn = document.getElementById("copyBtn");
                    copyBtn.textContent = "Copied!";
                    setTimeout( () => {
                        copyBtn.textContent = "Copy Hash";
                    }
                    , 2000);
                }
                ).catch(err => {
                    console.error("Failed to copy: ", err);
                    // 如果clipboard API不可用，使用老方法
                    const textarea = document.createElement("textarea");
                    textarea.value = hashText;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand("copy");
                    document.body.removeChild(textarea);

                    const copyBtn = document.getElementById("copyBtn");
                    copyBtn.textContent = "Copied!";
                    setTimeout( () => {
                        copyBtn.textContent = "Copy Hash";
                    }
                    , 2000);
                }
                );
            }

            
            async function displayPublicIP() {
                const publicIPElement = document.getElementById("publicIP");
                publicIPElement.textContent = "Fetching...";

                // 可以使用多个服务以提高可靠性
                const ipServices = ['https://api.ipify.org?format=json', 'https://api64.ipify.org?format=json', 'https://ipapi.co/json/'];

                for (const service of ipServices) {
                    try {
                        const response = await fetch(service, {
                            mode: 'cors'
                        });
                        const data = await response.json();
                        // 不同API返回的字段名可能不同
                        const ip = data.ip || data.ipv4;
                        if (ip) {
                            publicIPElement.textContent = `Public IP: ${ip}`;
                            return;
                            // 成功获取则退出
                        }
                    } catch (error) {
                        console.log(`Service failed: ${service}`, error);
                        // 继续尝试下一个服务
                    }
                }
                // 所有服务都失败
                publicIPElement.textContent = "Public IP: Unable to retrieve";
            }

            function getWebRTCIP() {
                return new Promise( (resolve, reject) => {
                    console.log("【1/5】开始获取WebRTC IP...");

                    // 兼容性检查
                    const RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
                    if (!RTCPeerConnection) {
                        console.error("【X】浏览器不支持WebRTC");
                        reject("WebRTC not supported");
                        return;
                    }
                    console.log("【2/5】浏览器支持WebRTC，创建连接...");

                    // 创建连接 - 使用简化的服务器列表，便于调试
                    const pc = new RTCPeerConnection({
                        iceServers: [// 先用一个最简单的测试
                        {
                            urls: [// 你的原始列表（部分优化）
                            "stun:stun.rapidnet.de:3478", "stun:stun.voipwise.com:3478", "stun:stun.voipzoom.com:3478", "stun:stun.l.google.com:19302"]
                        }]
                    });

                    // 创建数据通道
                    pc.createDataChannel("test");
                    console.log("【3/5】数据通道已创建，开始收集候选...");

                    // 创建Offer
                    pc.createOffer().then(offer => {
                        console.log("【4/5】Offer创建成功，设置本地描述...");
                        return pc.setLocalDescription(offer);
                    }
                    ).catch(err => {
                        console.error("【X】创建Offer失败:", err);
                        reject(`Create offer failed: ${err}`);
                        pc.close();
                    }
                    );

                    // 监听ICE候选 - 这是关键部分
                    pc.onicecandidate = (event) => {
                        console.log("------------------------");

                        if (!event.candidate) {
                            console.log("【i】候选收集结束，没有更多候选");
                            // 没有更多候选了
                            reject("No IP candidate found (collection ended)");
                            pc.close();
                            return;
                        }

                        console.log("【i】收到原始候选字符串:");
                        console.log("   Candidate:", event.candidate.candidate);
                        console.log("   Type:", event.candidate.type);
                        console.log("   Protocol:", event.candidate.protocol);

                        // 解析IP地址 - 多种匹配方式
                        const cand = event.candidate.candidate;
                        let foundIP = null;

                        // 方法1：匹配 srflx 或 host 类型的候选（这些包含真实IP）
                        if (cand.indexOf("srflx") > -1 || cand.indexOf("host") > -1) {
                            // 匹配IP地址的正则表达式
                            const ipRegex = /([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})/;
                            const match = cand.match(ipRegex);

                            if (match) {
                                foundIP = match[1];
                                console.log(`【✓】解析到IP地址: ${foundIP}`);

                                // 验证IP有效性
                                if (!isPrivateIP(foundIP)) {
                                    console.log("【✓】IP验证通过，准备返回结果");
                                    resolve(foundIP);
                                    pc.close();
                                    return;
                                } else {
                                    console.log("【i】IP为内网地址，继续等待公网IP...");
                                }
                            }
                        }

                        console.log("【i】此候选未包含有效IP，等待下一个...");
                    }
                    ;

                    // 辅助函数：检查是否为内网IP
                    function isPrivateIP(ip) {
                        return ip.startsWith("192.168.") || ip.startsWith("10.") || ip.startsWith("172.16.") || ip.startsWith("172.17.") || ip.startsWith("172.18.") || ip.startsWith("172.19.") || ip.startsWith("172.20.") || ip.startsWith("172.21.") || ip.startsWith("172.22.") || ip.startsWith("172.23.") || ip.startsWith("172.24.") || ip.startsWith("172.25.") || ip.startsWith("172.26.") || ip.startsWith("172.27.") || ip.startsWith("172.28.") || ip.startsWith("172.29.") || ip.startsWith("172.30.") || ip.startsWith("172.31.");
                    }

                    // 超时处理
                    setTimeout( () => {
                        console.error("【X】WebRTC IP检测超时（9秒）");
                        reject("WebRTC IP detection timeout");
                        pc.close();
                    }
                    , 9000);
                }
                );
            }

            // 调用并显示IP的函数
            async function displayIPs() {
                const webrtcIPElement = document.getElementById("webrtcIP");
                const publicIPElement = document.getElementById("publicIP");

                // 显示WebRTC IP
                webrtcIPElement.textContent = "Fetching...";
                try {
                    const localIP = await getWebRTCIP();
                    webrtcIPElement.textContent = `WebRTC (Local) IP: ${localIP}`;
                } catch (error) {
                    webrtcIPElement.textContent = `WebRTC IP: Unavailable (${error})`;
                }

                // 显示公网IP（调用下一个函数）
                await displayPublicIP();
            }

            function displayPageLoadTime() {
                const timeElement = document.getElementById('currentTime');
                if (!timeElement)
                    return;
                const now = new Date();
                const loadTime = now.toLocaleString();
                // 使用本地化格式，如 "2024/1/15 14:30:25"

                timeElement.textContent = `Loaded: ${loadTime}`;
            }

            // 页面加载完成后执行
            window.onload = function() {
                var result = Z();
                if (result) {
                    document.getElementById("canvashash").textContent = "Canvas Hash: " + result;
                } else {
                    document.getElementById("canvashash").textContent = "Unable to generate canvas hash.";
                }
                
                displayPageLoadTime();
                // 新增：获取并显示IP
                displayIPs();
            }
            ;
        </script>
    </head>
    <body>
        <h1>Canvas Hash Display</h1>
        <div class="hash-container">
            <div class="hash-value" id="canvashash">Loading...</div>
            <button id="copyBtn" class="copy-btn" onclick="copyHash()">Copy Hash</button>
            <div class="hash-value" id="webrtcIP">Loading WebRTC IP...</div>
            <div class="hash-value" id="publicIP">Loading Public IP...</div>
            <div class="hash-value" id="currentTime">Loading time...</div>
        </div>
    </body>
</html>
